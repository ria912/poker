from collections import deque
from models.action import Action
from models.position import assignment_order
import random

class RoundManager:
    def __init__(self, table):
        self.table = table
        self.phase = 'preflop'
        self.players_to_act = deque()
        self.last_raiser = None

    def start_new_round(self):
        self.table.start_hand()
        self.phase = 'preflop'
        self.setup_action_queue()

    def setup_action_queue(self):
        all_active = [p for p in self.table.players if not p.has_folded and p.stack > 0]
        all_active_sorted = sorted(all_active, key=lambda p: assignment_order.index(p.position))

        if self.phase == "preflop":
            bb_index = next((i for i, p in enumerate(all_active_sorted) if p.position == "BB"), 0)
            ordered = all_active_sorted[bb_index + 1:] + all_active_sorted[:bb_index + 1]
        else:
            btn_index = next((i for i, p in enumerate(all_active_sorted) if p.position == "BTN"), 0)
            ordered = all_active_sorted[btn_index + 1:] + all_active_sorted[:btn_index + 1]

        self.players_to_act = deque(ordered)
        self.last_raiser = None

    def proceed_action(self):
        if not self.players_to_act:
            return

        player = self.players_to_act.popleft()
        if player.has_folded or player.stack == 0:
            return

        legal = Action.get_legal_actions(player, self.table)

        if player.is_human:
            action, amount = player.decide_action({
                "actions": legal,
                "pot": self.table.pot,
                "current_bet": self.table.current_bet,
                "min_bet": self.table.min_bet
            })
        else:
            if Action.CALL in legal:
                action = Action.CALL
            elif Action.CHECK in legal:
                action = Action.CHECK
            else:
                action = Action.FOLD
            amount = 0

        before_bet = self.table.current_bet
        Action.apply_action(player, action, self.table, amount)

        if self.table.current_bet > before_bet and action in [Action.BET, Action.RAISE, Action.ALL_IN]:
            self.last_raiser = player
            self.reset_players_to_act_from(player)

    def reset_players_to_act_from(self, raiser):
        active = [p for p in self.table.players if not p.has_folded and p.stack > 0]
        ordered = sorted(active, key=lambda p: assignment_order.index(p.position))
        if raiser not in ordered:
            return

        start_index = ordered.index(raiser)
        reordered = ordered[start_index + 1:] + ordered[:start_index]
        self.players_to_act = deque(reordered)

    def should_advance_phase(self):
        return not self.players_to_act

    def advance_phase(self):
        phase_order = ['preflop', 'flop', 'turn', 'river', 'showdown']
        next_index = phase_order.index(self.phase) + 1
        if next_index < len(phase_order):
            self.phase = phase_order[next_index]

            if self.phase == 'flop':
                self.table.community_cards = [self.table.deck.draw() for _ in range(3)]
                self.table.current_bet = 0
            elif self.phase in ['turn', 'river']:
                self.table.community_cards.append(self.table.deck.draw())
                self.table.current_bet = 0
            elif self.phase == 'showdown':
                self.handle_showdown()

            for p in self.table.players:
                p.current_bet = 0

            self.setup_action_queue()
        else:
            print("Showdown or hand is over")

    def handle_showdown(self):
        # TODO: 最も強い役を持つプレイヤーを判定する（今はランダム）
        active_players = [p for p in self.table.players if not p.has_folded]
        if not active_players:
            print("No players left for showdown.")
            return

        winner = random.choice(active_players)
        print(f"Winner is: {winner.name}")
        winner.stack += self.table.pot
        self.table.pot = 0
